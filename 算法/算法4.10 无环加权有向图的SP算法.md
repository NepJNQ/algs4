### 算法4.10 无环加权有向图的SP算法
---

#### 算法描述
+ Dijkstra算法中使用pq.delMin()保证了每个结点v只会放松一次,但操作pq开销较大,在**无环加权有向图中,拓扑排序也能保证每个顶点只会放松一次**

#### 实现
```Java
public class AcyclicSP {
    private DirectedEdge[] edgeTo;
    private double[] distTo;

    public AcyclicSP(EdgeWeightedDigraph G, int s){
        edgeTo = new DirectedEdge[G.V()];
        distTo = new double[G.V()];

        for (int v = 0; v < G.V(); v++)
            distTo[v] = Double.POSITIVE_INFINITY;
        distTo[s] = 0.0;
        Topological top = new Topological(G);//根据DAG建立拓扑排序
        for (int v:top.order()) relax(G,v);
    }

    private void relax(EdgeWeightedDigraph G, int v){
        for (DirectedEdge e: G.adj(v)){
            int w = e.to();
            if (distTo[w] > distTo[v]+e.weight()){
                distTo[w] = distTo[v]+e.weight();
                edgeTo[w] = e;
            }
        }
    }
    public double distTo(int v){}//s->v的距离
    public boolean hasPathTo(int v){}
    public Iterable<DirectedEdge> pathTo(int v){}
}
```

#### 算法分析
+ Topo顺序在**E+V**成正比时间内生成,则解决SP问题也与次成正比
+ Topo顺序与边的权重正负无关,则可以解决**负权重的最短路径问题**