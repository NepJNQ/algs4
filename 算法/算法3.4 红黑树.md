#### 算法3.4 红黑查找树
**红黑查找树是2-3树的具体实现**

#### 1. 替换3-结点
+ 红黑树的基本思想:**用标准的二叉查找树(全是2-结点)和一些额外信息(替换3-结点)来表示2-3查找树**
+ 结点类型:(结点的颜色指的是指向该结点的链接颜色)
    + 红链接:将两个2-结点连成3-结点
    + 黑链接:2-3树中的普通链接
```Java
 private class Node{
        Key key;
        Value val;
        Node left, right;
        int N;
        //结点颜色:指向该结点链接的颜色
        boolean color;

        Node(Key key, Value val, int N, boolean color){
            this.key = key;
            this.val = val;
            this.N = N;
            this.color = color;
        }
    }
```

#### 2. 等价定义
+ 红链接均为左链接
+ 没有一个结点同时和两条红链接相连(4-结点)
+ 该树是**黑色平衡**,即任意空链接到根结点的路径上黑链接数量相同

#### 3. 一一对应
将红黑树中所有红链接画水平,那所有空链接到根结点的距离都将相同.再将红链接相连的结点合并,即可得到2-3树.**红黑树结合了二叉树的高效查找和2-3树的平衡插入**

![image](https://github.com/NepJNQ/algs4Note/raw/master/3/RB1.jpg)

---

#### 4. 主要操作

#### 4.1 旋转
某些操作下,可能出现红色右链接或两个连续红链接,需要**旋转**改变红链接指向,旋转操作保证了**有序性和完美平衡性**
+ 左旋:避免产生右红链接
+ 右旋:处理左侧两个连续红链接

![image](https://github.com/NepJNQ/algs4Note/raw/master/3/RB2.jpg)

```Java
Node rotateLeft(Node h){
    Node x = h.right;
    h.right = x.left;
    x.left = h;
    x.color = h.color;//初始h的颜色不确定
    h.color = RED;//旋转后左链接置红色
    x.N = h.N;
    h.N = 1+size(h.left)+size(h.right);
    return x;
}
Node rotateRight(Node h){
    Node x = h.left;
    h.left = x.right;
    x.right = h;
    x.color = h.color;
    h.color = RED;
    x.N = h.N;
    h.N = 1+size(h.left)+size(h.right);
    return x;
}
```

#### 4.2 插入

#### 4.2.1 向2-结点插入新键
当只有一个2-结点时,插入一个新键后立刻旋转
+ 新键<老键:增加红色结点,新树等价于3-结点
+ 新键>老键:增加红色结点,但产生红右链,`root=rotateLeft(root)`,旋转修正

#### 4.2.2 向双键树(3-结点)插入新键
+ 新键>原数中两个键:最简单的情况,直接连接到3-结点右链接.此时树是平衡的,将两个链接的颜色由黑变红,即得到一棵由三个结点组成的,高为2的平衡树,真好对于2-3树
+ 新键<原数中两个键:连接到最左边的空链接,形成了连续两条红链接(4-结点),只需把上层红链接**右旋转**即可回到情况一
+ 新键介于二者之间:连接到左结点的右链(红色),有形成两条连续红链接,将右链左旋,回到情况二

#### 4.2.3 颜色转换
在上述向双键树插入新键操作后,**子结点都由红变黑,父结点变红**,这是**局部变换**,不会影响整棵树的**黑色平衡性**
```Java
private void flipColors(Node h){
        h.color = RED;
        h.left.color = BLACK;
        h.right.color = BLACK;
    }
```

#### 4.2.4 根结点总为黑色
红色结点说明**结点是3-结点的一部分**,但根结点并不满足,则每次插入后根结点都设为黑,且**每当根结点由红变黑,树高加1**

#### 4.2.5 红链接向上传递
在2-3树中,在一个3-结点下插入新键->临时创建4-结点->分解,传递中间值到父结点->父结点是一个2-结点或为根结点->若为后者,则分解根结点.<br>对应到红黑树中就是**红链接向上传递**,插入->旋转->颜色转换->红链接转移至中结点->重复(和新插入结点效果一样)->直到非红右链接/非连续红链接/非根结点

![image](https://github.com/NepJNQ/algs4Note/raw/master/3/RB3.jpg)

#### 4.2.6 插入算法
+ 插入操作只有以下三种:
    + 左子结点黑色,右子结点红色->左旋
    + 左子结点和左子结点的左子结点都为红色->右旋
    + 左右子结点都为红色->颜色转换
+ 红黑树平衡性的调整是**自下而上**的,所以在put()递归插入语句后,再用if判断以上三种情况,并且,三条语句有顺序(根据4.2.2分析)

```Java
public class RedBlackBST<Key extends Comparable<Key>, Value > {
    private Node root;

    private static final boolean RED = true;
    private static final boolean BLACK = false;

    private class Node{}

    private boolean isRed(Node x){
        if (x == null) return false;
        return x.color == RED;
    }
    private Node rotateLeft(Node h){}
    private Node rotateRight(Node h){}
    private void flipColors(Node h){}

    public int size(){ return size(root);}
    private int size(Node h){
        if (h == null) return 0;
        else return h.N;
    }
    public void put(Key key, Value val){
        root = put(root,key,val);
        root.color = BLACK;
    }
    
    private Node put(Node h, Key key, Value val){
        if (h == null){
            //新建结点都用红链接
            return new Node(key, val, 1, RED);
        }

        int cmp = key.compareTo(h.key);
        if (cmp < 0) h.left = put(h.left, key, val);//小于key,进入左子树
        else if(cmp > 0) h.right = put(h.right, key, val);//大于key,进入右子树
        else h.val = val;//已存在,则更新val

        //处理右侧红链接
        if (isRed(h.right) && !isRed(h.left)) h = rotateLeft(h);
        //处理连续红链接
        if (isRed(h.left) && isRed(h.left.left)) h = rotateRight(h);
        //颜色转换
        if (isRed(h.left) && isRed(h.right)) flipColors(h);

        h.N = size(h.right)+size(h.left)+1;
        return h;
    }
}
```

#### 示例

![image](https://github.com/NepJNQ/algs4Note/raw/master/3/RB4.jpg)



