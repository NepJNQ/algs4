### 算法1.1 下压栈(LIFO)

---

#### 1.1.1 可动态调整数组大小的实现
```Java
public class ResizingArrayStack<Item> implements Iterable<Item> {
	private Item[] a = (Item []) new Object[1];//元素栈
	private int N;//元素个数

	public boolean isEmpty() {
		return N == 0;
	}

	public int size() {
		return N;
	}

	private void resize(int max) {
		Item[] temp = (Item []) new Object[max];
		for(int i = 0; i < max; i++) {
			temp[i] = a[i];
		}
		a = temp;
	}//调整数组大小

	public void push(Item item) {
		if(N == a.length) resize(2*a.length);
		a[N++] = item;
	}//添加元素到栈顶

	public Item pop() {
		Item item = a[--N];
		a[N] = null;//防止对象游离
		if(N > 0 && N == a.length/4) resize(a.length/2);
		return item;
	}//从栈顶删除元素

	@Override
	public Iterator<Item> iterator() {
		return new ReverseArrayIterator;
	}

	private class ReverseArrayIterator implements Iterator<Item> {
		private i = N;
		@Override
		public boolean hasNext() {
			return i > 0;
		}
		@Override
		public Item next() {
			return a[--i];
		}
		@Override
		public void remove() {}
	}
}
```

#### 要点
1. 可变数组下压栈的主类和内部类需要分别实现Iterable<Item>,Iterator<Item>接口,从而实现LIFO逆序迭代,否则会按照数组FIFO迭代;
2.  algs4书中对于remove()总为空,避免在迭代中穿插修改数据结构的操作
3. 为保证数组缩减后有一半的空间利用率,判断条件应该是N == a.length/4
4. 删除栈顶元素时,实际上被弹出元素的引用仍保存在数组中,但该元素永远不会被访问,直到下次push()后,原有引用指向新元素.Java垃圾收集器才会回收空间,期间造成空间浪费,使用a[N] = null避免元素游离.


#### 特点
1. 算法1.1的每项操作用时与集合大小无关:操作始终只针对栈顶元素;
2. 空间需求总是不超过集合大小乘一个常数;
3. 栈永远不会溢出,使用率也不会低于四分之一,除非栈为空时,数组大小为1;









