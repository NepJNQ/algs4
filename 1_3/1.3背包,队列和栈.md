### 背包,队列和占道

#### 1.3.1API

##### 1.3.1.3可迭代的集合类型
如果集合是可迭代的,就能够使用foreach语句

##### 1.3.1.4背包
背包(Bag)是一种不支持从中删除元素的集合类型

##### 1.3.1.5先进先出队列*
队列(Queue)是一种基于先进先出(FIFO)的集合类型</br>
**使用情形:** 在集合保存元素的同时保存相对顺序:使它们入列顺序和出列顺序相同

##### 1.3.1.6下压栈*
栈(Stack)是一种基于后进先出(LIFO)的集合类型</br>
**使用情形:** 在集合保存元素的同时颠倒相对顺序

##### 1.3.1.7算术表达式求值*
**求值算法:双栈运算法**</br>
**操作:**</br>
1. 准备两个栈:运算符栈,操作数栈
2. 忽略左括号,将操作数和运算符分别压入对应栈内
3. 遇到右括号,弹出一个运算符,弹出所需数量的操作数,并将运算符和操作数的结果压入操作数栈</br>

**漏洞:**</br>
1. 最多只能有两个操作数在括号内运算
2. 必须有左括号和右括号</br>

---

#### 1.3.2集合类数据类型的实现

##### 1.3.2.2 泛型*
创建泛型数组在Java中不被允许,需要使用强转
```Java
Item[] a = (Item[]) new Object[cap];
```
##### 1.3.2.4对象游离*
栈中元素pop()后,被弹出元素的引用依旧存在于数组中,但元素不会再被访问,垃圾回收机无法判断,除非引用被覆盖,这是需要使引用指向null
```Java
Item item = a[--N];
a[N] = null;//防止游离
```

##### 1.3.2.5迭代*
**实现可迭代类的方法:**</br>
1. 集合实现Iterable<Item>接口,在类中重写iterator()方法,并返回迭代器Iterator<Item>
2. 根据不同要求,可以编写子类实现Iterator<Item接口,重写hasNext(),next(),remove()方法,生成迭代器


